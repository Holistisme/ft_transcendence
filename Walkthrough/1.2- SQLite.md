# âœ… RÃ©sumÃ© gÃ©nÃ©ral

* CrÃ©er un backend en **Node.js avec Fastify** (exigÃ© par le module Web)
* Ajouter une base **SQLite** (exigÃ©e par le module DB)
* Exposer une **API REST** avec deux routes `/users` (GET & POST)
* Relier le tout avec ton **frontend SPA TypeScript**

---

## ğŸ”§ DÃ©tail technique de chaque fichier et concept

---

## ğŸ“ `/backend` â€” ton rÃ©pertoire serveur

Câ€™est ici que vit ton **serveur Fastify**, Ã©crit en TypeScript.

---

### ğŸ“„ `server.ts` â€” Point dâ€™entrÃ©e

```ts
import Fastify from 'fastify';
import { userRoutes } from './routes/users';

const app = Fastify();

app.register(userRoutes);

app.listen({ port: 3001 }, (err, address) => {
  if (err) throw err;
  console.log(`âœ… Server ready at ${address}`);
});
```

ğŸ§  Ce que Ã§a fait :

* CrÃ©e une **instance du serveur Fastify**
* **Charge tes routes personnalisÃ©es** (`userRoutes`)
* DÃ©marre le serveur HTTP sur le port `3001`
* Affiche un message de succÃ¨s ou une erreur

ğŸ“ Quand tu lances `npx ts-node server.ts`, ce fichier exÃ©cute tout ton backend.

---

### ğŸ“„ `routes/users.ts` â€” Routes API pour `/users`

```ts
server.get('/users', async () => {
  return await db.all('SELECT * FROM users');
});
```

* Quand le frontend fait un `GET` vers `/users` â†’ tu renvoies tous les utilisateurs depuis la base de donnÃ©es.

```ts
server.post('/users', async (req, reply) => {
  const { username } = req.body;
  await db.run('INSERT INTO users (username) VALUES (?)', username);
});
```

* Quand un utilisateur sâ€™enregistre (via `POST`), tu ajoutes un nouvel enregistrement dans la base SQLite.
* Si Ã§a Ã©choue (ex. : doublon), tu renvoies une erreur avec un `status 400`.

---

### ğŸ“„ `db.ts` â€” Connexion Ã  SQLite

```ts
import sqlite3 from 'sqlite3';
import { open } from 'sqlite';

export async function initDB() {
  return open({
    filename: './db.sqlite3',
    driver: sqlite3.Database
  });
}
```

ğŸ” Ce fichier :

* CrÃ©e une **connexion vers ta base SQLite**
* Te permet de faire des requÃªtes SQL (`SELECT`, `INSERT`, `UPDATE`, etc.)
* Est **asynchrone**, car SQLite peut lire/Ã©crire sur le disque

---

### ğŸ—ƒ `db.sqlite3` â€” Fichier de la base

Ce fichier est gÃ©nÃ©rÃ© automatiquement par SQLite.
Il contient physiquement toutes les **donnÃ©es de ton app** (utilisateurs, scores...).

Tu ne dois **jamais lâ€™ouvrir Ã  la main** pendant que ton serveur tourne.
Tu peux utiliser des outils comme `sqlitebrowser` pour lâ€™explorer hors ligne.

---

## ğŸ§  Rappels de concepts

| Concept    | RÃ´le                                                     |
| ---------- | -------------------------------------------------------- |
| Fastify    | Framework backend minimaliste Node.js                    |
| SQLite     | Base de donnÃ©es lÃ©gÃ¨re, locale (fichier `.sqlite3`)      |
| Route GET  | Sert Ã  lire des infos (`/users`)                         |
| Route POST | Sert Ã  crÃ©er une ressource (ajouter un user)             |
| API REST   | Architecture standard pour communiquer avec ton frontend |
| `ts-node`  | Lance du TypeScript directement sans build               |
| `open()`   | Connecte la BDD via la lib `sqlite`                      |

---

## ğŸ“¡ Ce que peut faire ton **frontend**

Exemple dans ton SPA TypeScript :

```ts
fetch('http://localhost:3001/users', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ username: 'adesille' })
})
```

* Cela envoie un utilisateur Ã  ton backend Fastify.
* Fastify lâ€™insÃ¨re en base avec SQLite.
* Ensuite, tu peux faire un `GET /users` pour lister tous les joueurs.
